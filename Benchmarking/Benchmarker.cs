using System;
using System.IO;
using System.Collections.Generic;
using System.Diagnostics;

namespace Cephei
{
  using Numericals;
  using System.Globalization;

  namespace Benchmarking
  {
    /// <summary>
    /// The Benchmarker class is used, as its name implies, to benchmark proccesses. It is used to execute operations and analyze the time taken and the memory
    /// variation.
    /// </summary>
    public abstract class Benchmarker
    {
      /// <summary>
      /// Creates a new benchmarker, assigning a new Stopwatch to it.
      /// </summary>
      public Benchmarker() : this(new Stopwatch())
      { }
      /// <summary>
      /// Creates a new benchmarker class, looping its main method for an amount of times.
      /// </summary>
      /// <param name="loops">Amount of times to loop. Use 0 to not execute the main method on construction.</param>
      public Benchmarker(int loops) : this(new Stopwatch(), loops)
      { }
      /// <summary>
      /// Creates a new Benchmarker, outputting data to a writer.
      /// </summary>
      /// <param name="writer">The writer to output data to.</param>
      /// <param name="loops">Number of times to loop the main method.</param>
      public Benchmarker(TextWriter writer, int loops) : this(writer, new Stopwatch(), loops)
      { }
      /// <summary>
      /// Creates a new benchmarker, assigning a stopwatch to it and making it benchmark for a number of times.
      /// </summary>
      /// <param name="stopwatch">The stopwatch to assign to it.</param>
      /// <param name="loops">Number of times to benchmark.</param>
      public Benchmarker(Stopwatch stopwatch, int loops) : this(stopwatch) => Benchmark(loops);
      /// <summary>
      /// Creates a new Benchmarker class, assigning  a stopwatch to it, while also making it execute its benchmark. Outputs the result to the writer.
      /// </summary>
      /// <param name="writer">Writer to assign to it.</param>
      /// <param name="stopwatch">Stopwatch to assign to it.</param>
      /// <param name="loops">Loops to execute on benchmark.</param>
      public Benchmarker(TextWriter writer, Stopwatch stopwatch, int loops) : this(stopwatch) => Benchmark(writer, loops);
      /// <summary>
      /// Creates a benchmarker, assigning a custom stopwatch to it.
      /// </summary>
      /// <param name="stopwatch">The stopwatch to use.</param>
      public Benchmarker(Stopwatch stopwatch)
      {
        Stopwatch = stopwatch;
        Reports = new List<Report>();
      }

      //
      // PUBLIC
      //

      // STRUCTS

      /// <summary>
      /// BenchmarkReports are generated by the Benchmarker, containing relevant data such as memory usage at the time of creation and time elapsed.
      /// </summary>
      public readonly struct Report : IFormattable
      {
        /// <summary>
        /// Creates a new Benchmark report, using a Stopwatch and a list of reports as reference. It then adds itself to the list.
        /// It will call the GarbageCollector automatically, but the stopwatch will be halted beforehand to prevent time loss.
        /// </summary>
        /// <param name="stopwatch">Stopwatch to use. It is automatically stopped.</param>
        /// <param name="reports">List of reports to use as reference.</param>
        /// <param name="iterations">Number of iterations that were executed.</param>
        public Report(Stopwatch stopwatch, IList<Report> reports, int iterations)
        {
          stopwatch.Stop();
          PreGCMemory = GC.GetTotalMemory(false);
          Memory = GC.GetTotalMemory(true);
          TimeElapsed = stopwatch.Elapsed;
          int rc = reports.Count;
          MemoryChange = rc > 0 ? Memory - reports[rc - 1].Memory : Memory;
          Iterations = iterations;
          reports.Add(this);
        }

        //
        // OVERRIDES
        //

        /// <summary>
        /// Returns a string containing this report's main data.
        /// </summary>
        /// <returns>A string containing this report's data.</returns>
        public override string ToString() 
          => ToString("N0", CultureInfo.CurrentCulture.NumberFormat);
        /// <summary>
        /// Returns a string with this report's data using a specific formatting for the numbers.
        /// </summary>
        /// <param name="format">Format to use.</param>
        /// <param name="formatter">Culture formatter for the number.</param>
        /// <returns>A formatted string.</returns>
        public string ToString(string format, IFormatProvider formatter) 
          => ToString(format, "", formatter, CultureInfo.CurrentCulture.DateTimeFormat);
        /// <summary>
        /// Returns a string with this report's data using specific formatting.
        /// </summary>
        /// <param name="numformat">Format to use for numbers.</param>
        /// <param name="prefix">SIPrefixes prefix to use.</param>
        /// <param name="timeformat">Format to use for the time.</param>
        /// <param name="numprovider">FormatProvider for the numbers.</param>
        /// <param name="dateprovider">FormatProvider for the dates.</param>
        /// <returns>A formatted string.</returns>
        public string ToString(string numformat, string prefix, IFormatProvider numprovider, IFormatProvider dateprovider, string timeformat = @"ss\s\.ffffff\u\s")
          => "Pre GC Memory: " + SIPrefixes.ToString(PreGCMemory, prefix, numformat, numprovider) + "B" +
            " (Garbage=" + SIPrefixes.ToString(GarbageSize, prefix, numformat, numprovider) + "B, " + GarbagePercent.ToString("P2") + ")\n" +
            "Memory: " + SIPrefixes.ToString(Memory, prefix, numformat, numprovider) + "B (" + (MemoryChange > 0 ? "+" : "")
            + SIPrefixes.ToString(MemoryChange, prefix, numformat, numprovider) + "B, "
            + SIPrefixes.ToString(MemoryPerIteration, prefix, numformat, numprovider) + "B/i)\n"
            + "Time Elapsed: " + TimeElapsed.ToString(timeformat, dateprovider) + " (" + TimePerIteration.ToString(timeformat, dateprovider) + "/i)";

        //
        // PUBLIC
        //

        // VARIABLES

        /// <summary>
        /// Amount of time spent until the creation of this report.
        /// </summary>
        public readonly TimeSpan TimeElapsed;

        /// <summary>
        /// Amount of memory used at the time.
        /// </summary>
        public readonly long Memory;

        /// <summary>
        /// Amount of memory that has changed.
        /// </summary>
        public readonly long MemoryChange;

        /// <summary>
        /// Memory usage prior to Garbage Collection.
        /// </summary>
        public readonly long PreGCMemory;

        /// <summary>
        /// Amount of iterations that were executed.
        /// </summary>
        public readonly int Iterations;

        // PROPERTIES

        /// <summary>
        /// Gets the amount of time spent per iteration (in milliseconds).
        /// </summary>
        public TimeSpan TimePerIteration => new TimeSpan(TimeElapsed.Ticks / Iterations);

        /// <summary>
        /// Gets the amount of memory used per iteration.
        /// </summary>
        public long MemoryPerIteration => MemoryChange / Iterations;

        /// <summary>
        /// Gets the size of Garbage memory (in bytes).
        /// </summary>
        public long GarbageSize => PreGCMemory - Memory;

        /// <summary>
        /// How many % of PreGCMemory is garbage.
        /// </summary>
        public double GarbagePercent => GarbageSize / (double)PreGCMemory;
      }

      // VARIABLES

      /// <summary>
      /// List of reports that were generated by the last benchmark.
      /// </summary>
      public readonly List<Report> Reports;

      /// <summary>
      /// The stopwatch that is being used by this benchmarker.
      /// </summary>
      public Stopwatch Stopwatch;

      /// <summary>
      /// The benchmarker's current iteration.
      /// </summary>
      public int Iteration;

      // METHODS

      /// <summary>
      /// This is the method that the Benchmarker is to analyze.
      /// </summary>
      public abstract void MainMethod();

      /// <summary>
      /// Benchmarks the main method.
      /// </summary>
      public void Benchmark(int loops = 1)
      {
        Reports.Clear();
        new Report(Stopwatch, Reports, 1);
        Stopwatch.Restart();
        for (Iteration = 0; Iteration < loops; Iteration++) MainMethod();
        new Report(Stopwatch, Reports, loops);
      }
      /// <summary>
      /// Benchmarks the benchmarker's main method, outputting its results.
      /// </summary>
      /// <param name="writer">The TextWriter to use.</param>
      /// <param name="loops">Amount of times to loop.</param>
      public void Benchmark(TextWriter writer, int loops = 1)
      {
        writer.WriteLine("Preparing to benchmark for " + loops.ToString() + " iterations...");
        Benchmark(loops);
        writer.WriteLine("Benchmarking finished. Results (" + Reports.Count.ToString() + "):");
        writer.WriteLine(string.Join("\n", Reports));
      }
    }
  }
}