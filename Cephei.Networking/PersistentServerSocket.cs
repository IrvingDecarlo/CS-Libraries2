using Cephei.Logging;
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Cephei.Networking
{
  /// <summary>
  /// The generic PersistentServerSocket is a socket server that continuously listens to a local port, reading the incoming message and raising events whenever
  /// a new connection is established.
  /// </summary>
  /// <typeparam name="T">Message type that the server works with.</typeparam>
  public abstract class PersistentServerSocket<T> : PersistentServerSocket
  {
    /// <summary>
    /// Creates a PersistentServerSocket that listens to a local endpoint.
    /// </summary>
    /// <param name="endpoint">Endpoint to use.</param>
    /// <param name="listening">Should the server automatically start listening and interpreting incoming connections?</param>
    public PersistentServerSocket(EndPoint endpoint, bool listening = true) : base(endpoint, listening)
    { }

    #region overrides

    /// <summary>
    /// Handles an incoming connection.
    /// </summary>
    /// <param name="socket">Socket that handles the connection.</param>
    /// <param name="cancelsource">Cancellation token source.</param>
    protected sealed override async void HandleConnection(Socket socket, CancellationTokenSource cancelsource)
    {
      T msg = await GetMessage(socket, cancelsource);
      GetLogger()?.LogDetail("Received message: " + msg);
      if (OnConnectionEstablished is null) await OnUnhandledConnection(socket, msg);
      else OnConnectionEstablished.Invoke(socket, msg);
    }

    #endregion

    #region public

    /// <summary>
    /// The OnConnectionEstablished event is invoked when an incoming connection is validated and established, passing the connection's socket and incoming message
    /// as parameters.
    /// </summary>
    public event Action<Socket, T>? OnConnectionEstablished;

    #endregion

    #region protected

    /// <summary>
    /// Extracts a message from an incoming connection.
    /// </summary>
    /// <param name="socket">Socket that handles the connection.</param>
    /// <param name="cancelsource">Cancellation token source.</param>
    /// <returns>The message from the incoming connection.</returns>
    protected abstract Task<T> GetMessage(Socket socket, CancellationTokenSource cancelsource);

    /// <summary>
    /// OnUnhandledConnection is called when OnConnectionEstablished has no consumers, meaning the created connection would never be handled and its socked never disposed.
    /// </summary>
    /// <param name="socket">Socket generated by the connection.</param>
    /// <param name="message">Message extracted from the socket.</param>
    /// <returns>The task.</returns>
    protected virtual async Task OnUnhandledConnection(Socket socket, T message)
    {
      string msg = "UNHANDLED CONNECTION: " + (message is null ? "null" : message.ToString());
      GetLogger()?.LogDetail(msg);
      await socket.SendAsync(Encoding.UTF8.GetBytes(msg));
      socket.Dispose();
    }

    #endregion
  }
  /// <summary>
  /// The PersistentServerSocket class offers a base for all servers that continuously listen to a local IP port.
  /// </summary>
  public abstract class PersistentServerSocket : IDisposable
  {
    /// <summary>
    /// Creates a PersistentServerSocket that listens to a local endpoint.
    /// </summary>
    /// <param name="endpoint">Endpoint to use.</param>
    /// <param name="listening">Should the server automatically start listening and interpreting incoming connections?</param>
    public PersistentServerSocket(EndPoint endpoint, bool listening = true)
    {
      this.endpoint = endpoint;
      socket = GetSocket(endpoint);
      socket.Bind(endpoint);
      socket.Listen(GetBacklogSize());
      Listening = listening;
    }

    #region overrides

    /// <summary>
    /// Gets the server's endpoint to string.
    /// </summary>
    /// <returns>The server's endpoint to string.</returns>
    public override string ToString() => endpoint.ToString();

    /// <summary>
    /// Disposes the Server.
    /// </summary>
    /// <remarks>Overriders must call this or the underlying server socket will never be disposed.</remarks>
    public virtual void Dispose()
    {
      Listening = false;
      socket.Dispose();
    }

    #endregion

    #region public

    // PROPERTIES

    /// <summary>
    /// Is the server currently listening?
    /// </summary>
    public bool Listening
    {
      set
      {
        if (value == listening) return;
        listening = value;
        if (value) StartListening();
        else cancel_source?.Cancel();
      }
      get => listening;
    }

    // METHODS

    /// <summary>
    /// Gets the server's socket address.
    /// </summary>
    /// <returns>The server's socket address.</returns>
    public SocketAddress GetSocketAddress() => endpoint.Serialize();

    #endregion

    #region protected

    // METHODS

    /// <summary>
    /// Gets the socket to be used by the server.
    /// </summary>
    /// <param name="endpoint">Endpoint that will be used by the server.</param>
    /// <returns>The socket to be used by the server.</returns>
    protected abstract Socket GetSocket(EndPoint endpoint);

    /// <summary>
    /// Gets the logger for outputting data to.
    /// </summary>
    /// <returns>The logger for outputting data to.</returns>
    protected abstract ILogger? GetLogger();

    /// <summary>
    /// Gets the backlog size for queueing connections.
    /// </summary>
    /// <returns>The backlog size for queueing connections (default 16).</returns>
    protected virtual int GetBacklogSize() => 16;

    /// <summary>
    /// Checks if the incoming connection is to be accepted and interpreted.
    /// </summary>
    /// <param name="socket">Socket generated by the new connection.</param>
    /// <param name="endpoint">The local server's endpoint.</param>
    /// <returns>True if the incoming connection is to be accepted and interpreted.</returns>
    protected abstract bool ValidateConnection(Socket socket, EndPoint endpoint);

    /// <summary>
    /// Handles the connection after the socket has been received and accepted.
    /// </summary>
    /// <param name="socket">Socket generated by the connection.</param>
    /// <param name="cancelsource">CancellationTokenSource for asynchronous connection handlers.</param>
    /// <remarks>The socket is not disposed. It must be done so by the object that implements this class.</remarks>
    protected abstract void HandleConnection(Socket socket, CancellationTokenSource cancelsource);

    /// <summary>
    /// OnConnectionDenied is called when a connection attempt fails to be validated by ValidateConnection.
    /// </summary>
    /// <param name="socket">Socket generated by the failed attempt.</param>
    /// <param name="remotestr">String identifying the incoming connection's EndPoint.</param>
    protected virtual void OnConnectionDenied(Socket socket, string remotestr)
    {
      GetLogger()?.LogCritical($"Incoming connection rejected: {remotestr}.");
      socket.Dispose();
    }

    /// <summary>
    /// Actions to take when an unhandled exception is thrown while the server is listening.
    /// </summary>
    /// <param name="socket">Socket that was being used.</param>
    /// <param name="ex">The unhandled exception.</param>
    protected virtual async void OnUnhandledException(Socket? socket, Exception ex)
    {
      ILogger? logger = GetLogger();
      if (!(logger is null))
      {
        logger.LogCritical($"Exception unhandled while server {this} was listening:");
        logger.LogException(ex);
      }
      if (socket is null) return;
      try { await socket.SendAsync(Encoding.UTF8.GetBytes($"UNHANDLED EXCEPTION {ex.GetType()}: {ex.Message}")); }
      catch (Exception e)
      {
        if (!(logger is null))
        {
          logger.LogCritical("Failed to send exception message to sender:");
          logger.LogException(e);
        }
        if (e is ObjectDisposedException) return;
      }
      socket.Dispose();
    }

    #endregion

    #region private

    // FIELDS

    private readonly EndPoint endpoint;
    private readonly Socket socket;
    private CancellationTokenSource? cancel_source = null;
    private bool listening = false;

    // METHODS

    private async void StartListening()
    {
      ILogger? logger = GetLogger();
      Socket? socket = null;
      EndPoint? remote;
      string remotestr;
      logger?.LogDebug($"Listener is now listening on {endpoint}...");
      cancel_source = new CancellationTokenSource();
      while (listening)
      {
        try
        {
          socket = await this.socket.AcceptAsync();
          logger = GetLogger();
          remote = socket.RemoteEndPoint;
          remotestr = remote.ToString();
          logger?.LogDetail($"New connection from {remotestr}.");
          if (!ValidateConnection(socket, endpoint))
          {
            OnConnectionDenied(socket, remotestr);
            continue;
          }
          HandleConnection(socket, cancel_source);
        }
        catch (TaskCanceledException)
        {
          cancel_source.Dispose();
          cancel_source = null;
          break;
        }
        catch (Exception ex) { OnUnhandledException(socket, ex); }
      }
    }

    #endregion
  }
}
